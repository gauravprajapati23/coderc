<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CodeRC</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
    
<h3 id="heading1">CodeRC</h3>
<h6 id="heading2">Designed by Gaurav Prajapati</h6>

<div class="que-prompt">1.Assign1_setA</div>
<div class="code-area">
<button onclick="cc1()">Copy</button>
<pre id="id1">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "btree.h"
int main()
{
int ch,n,i,value,cnt;
struct bst *newnode,*root,*temp;
root=NULL;
while(1)
{
printf("\n---Binary Search Tree---\n");
printf("1.Insert\n");
printf("2.Search\n");
printf("3.Count Total Nodes\n");
printf("4.Count Leaf Nodes\n");
printf("5.Count Non Leaf Nodes\n");
printf("6.Inorder Traversal (Recursive)\n");
printf("7.Postorder Traversal (Recursive)\n");
printf("8.Preorder Traversal (Recursive)\n");
printf("9.Inorder Traversal (Non Recursive\n");
printf("10.Exit\n");
printf("Enter your choice:");
scanf("%d",&ch);
switch(ch)
{
case 1: printf("\nHow many nodes to create:");
scanf("%d",&n);
for(i=0;i&lt;n;i++)
{
newnode=create();
printf("\nEnter the node data:");
scanf("%d",&newnode->data);
if(root==NULL)
root=newnode;
else
insert(root,newnode);
}
break;
case 2: printf("\nEnter the node value to be searched:");
scanf("%d",&value);
temp=search(root,value);
if(temp==NULL)
printf("\nNode Not Found\n");
else
printf("\nNode Found\n");
break;
case 3: cnt=count(root);
printf("\nTotal Nodes=%d\n",cnt);
break;
case 4: cnt=countleaf(root);
printf("\nTotal Leaf Nodes=%d\n",cnt);
break;
case 5: cnt=countnleaf(root);
printf("\nTotal Non Leaf Nodes=%d\n",cnt);
break;
case 6: printf("\nInorder Traversal=");
inorder(root);
break;
case 7: printf("\nPostorder Traversal=");
postorder(root);
break;
case 8: printf("\nPreorder Traversal=");
preorder(root);
break;
case 9: printf("\nInorder Traversal=");
inorder_n(root);
break;
case 10: exit(0);
default: printf("\nInvalid Choice\n");
}
}
}
</pre>
</div>

<div class="que-prompt">btree.h</div>
<div class="code-area">
<button onclick="cc2()">Copy</button>
    <pre id="id2">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct bst
{
    int data;
    struct bst *lchild, *rchild;
} node;

int cnt = 0, leafcnt = 0, nleafcnt = 0;

struct bst *create()
{
    struct bst *temp = (struct bst *)malloc(sizeof(struct bst));
    temp-&gt;lchild = NULL;
    temp-&gt;rchild = NULL;
    return temp;
}

void insert(struct bst *r, struct bst *new1)
{
    if (new1-&gt;data &lt; r-&gt;data)
    {
        if (r-&gt;lchild == NULL)
            r-&gt;lchild = new1;
        else
            insert(r-&gt;lchild, new1);
    }

    if (new1-&gt;data &gt; r-&gt;data)
    {
        if (r-&gt;rchild == NULL)
            r-&gt;rchild = new1;
        else
            insert(r-&gt;rchild, new1);
    }
}
struct bst *search(struct bst *r, int key)
{
    struct bst *temp;
    temp = r;
    while (temp != NULL)
    {
        if (temp-&gt;data == key)
            return temp;
        if (key &lt; temp-&gt;data)
            temp = temp-&gt;lchild;
        else
            temp = temp-&gt;rchild;
    }
    return NULL;
}
int count(struct bst *temp)
{
    if (temp != NULL)
    {
        cnt++;
        count(temp-&gt;lchild);
        count(temp-&gt;rchild);
    }
    return cnt;
}
int countleaf(struct bst *temp)
{
    if (temp != NULL)
    {
        if (temp-&gt;lchild == NULL && temp-&gt;rchild == NULL)
            leafcnt++;
        countleaf(temp-&gt;lchild);
        countleaf(temp-&gt;rchild);
    }
    return leafcnt;
}
int countnleaf(struct bst *temp)
{
    if (temp != NULL)
    {
        if (temp-&gt;lchild != NULL || temp-&gt;rchild != NULL)
            nleafcnt++;
        countnleaf(temp-&gt;lchild);
        countnleaf(temp-&gt;rchild);
    }
    return nleafcnt;
}
void inorder(struct bst *temp)
{
    if (temp != NULL)
    {
        inorder(temp-&gt;lchild);
        printf("%d\t", temp-&gt;data);
        inorder(temp-&gt;rchild);
    }
}

void postorder(struct bst *temp)
{
    if (temp != NULL)
    {
        postorder(temp-&gt;lchild);
        postorder(temp-&gt;rchild);
        printf("%d\t", temp-&gt;data);
    }
}

void preorder(struct bst *temp)
{
    if (temp != NULL)
    {
        printf("%d\t", temp-&gt;data);
        preorder(temp-&gt;lchild);
        preorder(temp-&gt;rchild);
    }
}

void inorder_n(struct bst *r)
{
    struct bst *stack[100];
    int top = -1;
    if (r != NULL)
    {
        top++;
        stack[top] = r;
        r = r-&gt;lchild;
        while (top &gt;= 0)
        {
            while (r != NULL)
            {
                top++;
                stack[top] = r;
                r = r-&gt;lchild;
            }
            r = stack[top];
            top--;
            printf("%d\t", r-&gt;data);
            r = r-&gt;rchild;

            if (r != NULL)
            {
                top++;
                stack[top] = r;
                r = r-&gt;lchild;
            }
        }
    }
}

    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">2.Assign1_setB</div>
<div class="code-area">
<button onclick="cc3()">Copy</button>
    <pre id="id3">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node
{
        struct node *lchild;
        int info;
        struct node *rchild;
};


struct node *insert(struct node *ptr, int ikey);
void display(struct node *ptr,int level);
int isIdentical(struct node *, struct node *);
struct node *copyBinaryTree(struct node *r1);
void inOrderTraversal(struct node *nodeptr);
struct node *getNewNode(int data);
struct node *generateBTree();

int main()
{
 struct node *root=NULL,*root1=NULL,*ptr,*copy,*r1,*nodeptr;
        int choice,k,item;

        while(1)
        {
                printf("\n");
                printf("1.Insert Tree 1\n");
                printf("2.Insert Tree 2\n");
                printf("3.Display Tree 1\n");
                printf("4.Display Tree 2\n");
                printf("5.Check for Identical\n");
                printf("6.Copy\n");
                printf("7.Quit\n");
                
                printf("\nEnter your choice : ");
                scanf("%d",&choice);

                switch(choice)
                {

                case 1:
                        printf("\nEnter the key to be inserted : ");
                        scanf("%d",&k);
                        root = insert(root, k);
                        break;

        case 2:
                        printf("\nEnter the key to be inserted : ");
                        scanf("%d",&k);
                        root1 = insert(root1, k);
                        break;

        case 3:
            printf("\n");
            inOrderTraversal(root);
            printf("\n");
            break;

        case 4:
            printf("\n");
            inOrderTraversal(root1);
            printf("\n");
            break;

        case 5:
            printf("\n");
            if(isIdentical(root,root1))
                printf("Tree 1 and 2 are Identical\n");
            else
                printf("Tree 1 and 2 are Not Identical\n");
            printf("\n");
            break;

	case 6 :
		printf("\n");
     printf("Original Tree\n");
    inOrderTraversal(root);
     copy = copyBinaryTree(root);
    printf("\nCopy Tree\n");
    inOrderTraversal(copy);
     break;		
		
        case 7:
                        exit(1);

                 default:
                        printf("\nWrong choice\n");

                }
        }
      return 0;
}
struct node *insert(struct node *ptr, int ikey )
{
        if(ptr==NULL)
        {
         ptr = (struct node *) malloc(sizeof(struct node));
                ptr-&gt;info = ikey;
                ptr-&gt;lchild = NULL;
                ptr-&gt;rchild = NULL;
        }
        else if(ikey &lt; ptr-&gt;info) /*Insertion in left subtree*/
                ptr-&gt;lchild = insert(ptr-&gt;lchild, ikey);
        else if(ikey &gt; ptr-&gt;info) /*Insertion in right subtree */
                ptr-&gt;rchild = insert(ptr-&gt;rchild, ikey);
        else
                printf("Duplicate key\n");
        return(ptr);
}/*End of insert( )*/
int isIdentical( struct node *p1, struct node *p2)
{
        if(p1==NULL && p2==NULL)
                return 1;
        if(p1!=NULL && p2!=NULL && p1-&gt;info == p2-&gt;info)
                if(isIdentical(p1-&gt;lchild, p2-&gt;lchild) && isIdentical(p1-&gt;rchild, p2-&gt;rchild))
        return 1;
        return 0;
}
struct node *getNewNode(int data)
 {
    struct node* newNode = (struct node*)malloc(sizeof(struct node));
   newNode-&gt;info = data;
  newNode-&gt;lchild = NULL;
  newNode-&gt;rchild = NULL;
   return newNode;
}
struct node *copyBinaryTree(struct node *r1)
{
    if(r1 == NULL)
        return NULL;
        struct node* newNode = getNewNode(r1-&gt;info);
       newNode-&gt;lchild = copyBinaryTree(r1-&gt;lchild);
    newNode-&gt;rchild = copyBinaryTree(r1-&gt;rchild);
        return newNode;
}
void inOrderTraversal(struct node *nodeptr)
{
    if(nodeptr != NULL)
    {
        
        inOrderTraversal(nodeptr-&gt;lchild);
        /* Prints current node */
        printf("%d ", nodeptr-&gt;info);
         inOrderTraversal(nodeptr-&gt;rchild);
    }
}
    
    </pre>
</div>
<div>
    <hr>        
</div>

<div class="que-prompt">3.Assign2_setA</div>
<div class="code-area">
<button onclick="cc4()">Copy</button>
    <pre id="id4">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node
{
        struct node *lchild;
        int info;
        struct node *rchild;
};
struct node *insert(struct node *ptr, int ikey);
void display(struct node *ptr,int level);
int NodesAtLevel(struct node *ptr, int level) ;

int main()
{
        struct node *root=NULL,*root1=NULL,*ptr;
        int choice,k,item,level;

        while(1)
        {
                printf("\n");
                printf("1.Insert Tree \n");
                printf("2.Display Tree \n");
                printf("3.Number of Nodes \n");
                printf("4.Quit\n");
                printf("\nEnter your choice : ");
                scanf("%d",&choice);

                switch(choice)
                {

                case 1:
                        printf("\nEnter the key to be inserted : ");
                        scanf("%d",&k);
                        root = insert(root, k);
                        break;

        case 2:
            printf("\n");
            display(root,0);
            printf("\n");
            break;

        case 3:
            printf("\n");
            printf("Enter any level :: ");
            scanf("%d",&level);
            printf("\nNumber of nodes at [ %d ] Level :: %d\n",level,NodesAtLevel(root,level));
            break;

        case 4:
                        exit(1);
                 default:
                        printf("\nWrong choice\n");
                }
        }
        return 0;
}
struct node *insert(struct node *ptr, int ikey )
{
        if(ptr==NULL)
        {
      ptr = (struct node *) malloc(sizeof(struct node));
                ptr-&gt;info = ikey;
                ptr-&gt;lchild = NULL;
                ptr-&gt;rchild = NULL;
        }
        else if(ikey &lt; ptr-&gt;info) 
                ptr-&gt;lchild = insert(ptr-&gt;lchild, ikey);
        else if(ikey &gt; ptr-&gt;info) 
                ptr-&gt;rchild = insert(ptr-&gt;rchild, ikey);
        else
                printf("\nDuplicate key\n");
        return(ptr);
}

void display(struct node *ptr,int level)
{
        int i;
        if(ptr == NULL )
                return;
        else
    {
                display(ptr-&gt;rchild, level+1);
                printf("\n");
                for (i=0; i&lt;level; i++)
                printf("    ");
                printf("%d", ptr-&gt;info);
                display(ptr-&gt;lchild, level+1);
        }
}
int NodesAtLevel(struct node *ptr, int level)
{
        if(ptr==NULL)
                return 0;
        if(level==0)
                return 1;
        return NodesAtLevel(ptr-&gt;lchild,level-1) + NodesAtLevel(ptr-&gt;rchild,level-1);
}


    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">4.Assign2_setB</div>
<div class="code-area">
<button onclick="cc5()">Copy</button>
    <pre id="id5">
#include &lt;stdio.h&gt;
  
  void swap(int *a, int *b) 
  {
    int tmp = *a;
    *a = *b;
    *b = tmp;
  }
  
  void heapify(int arr[], int n, int i) 
  {
    int max = i; 
    int leftChild = 2 * i;
    int rightChild = 2 * i + 1;  
      if (leftChild &lt; n && arr[leftChild] &gt; arr[max])
      max = leftChild;
     if (rightChild &lt; n && arr[rightChild] &gt; arr[max])
      max = rightChild;
    if (max != i) 
    {
      swap(&arr[i], &arr[max]);
      heapify(arr, n, max);
    }
  }
void heapSort(int arr[], int n)
   {
       for (int i = n / 2 - 1; i &gt;= 0; i--)
      heapify(arr, n, i);
 
        for (int i = n - 1; i &gt;= 0; i--)
     {
      swap(&arr[0], &arr[i]); 
    heapify(arr, i, 0); 
    }
  }
  void display(int arr[], int n) 
  {
    for (int i = 0; i &lt; n; ++i)
      printf("%d ", arr[i]);
    printf("\n");
  }
     int main() 
  {
    int arr[] = {11, 34, 9, 5, 16, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
printf("Original array:\n");
    display(arr, n);
    heapSort(arr, n);
 printf("Sorted array:\n");
    display(arr, n);
  }

 
         
    </pre>
</div>        
<div>
    <hr>
</div>

<div class="que-prompt">5.Assign3_setAa</div>
<div class="code-area">
<button onclick="cc6()">Copy</button>
    <pre id="id6">
#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
void create(int a[10][10],int n)
{
printf("\n****TYPE 1 FOR YES & 0 FOR NO****\n");
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
a[i][j]=0;
if(i!=j)
{
printf("\nIs there any edge between %d & %d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
}
}

void display(int a[10][10],int n)
{
printf("\nThe Matrix is: \n");
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
printf("%d\t",a[i][j]);
}
printf("\n");
}
}
int main()
{
int a[10][10],n;
printf("\nEnter the no. of vertex: ");
scanf("%d",&n);
create(a,n);
display(a,n);
}


    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">6.Assign3_setAb</div>
<div class="code-area">
<button onclick="cc7()">Copy</button>
    <pre id="id7">
#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
void create(int a[10][10],int n)
{
printf("\n****TYPE 1 FOR YES & 0 FOR NO****\n");
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
a[i][j]=0;
if(i!=j)
{
printf("\nIs there any edge between %d & %d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
}
}
void inout(int a[10][10],int n)
{
int in=0,out=0,total=0;
printf("\nVertex\t\tIndegree\tOutdegree\tTotal Degree");
for(int i=0;i&lt;n;i++)
{
in=out=0;
for(int j=0;j&lt;n;j++)
{
in=in+a[j][i];
out=out+a[i][j];
}
total = in+out;
printf("\n%d\t\t%d\t\t%d\t\t%d",i+1,in,out,total);
}
}
int main()
{
int a[10][10],n;
printf("\nEnter the no. of vertex: ");
scanf("%d",&n);
create(a,n);
inout(a,n);
}


    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">7.Assign3_setBa</div>
<div class="code-area">
<button onclick="cc8()">Copy</button>
    <pre id="id8">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 20
typedef struct
{
int data[MAXSIZE];
int front, rear;
}QUEUE;
void initq(QUEUE *pq){
pq-&gt;front=pq-&gt;rear=-1;
}
void addq(QUEUE *pq,int n){
pq-&gt;data[++pq-&gt;rear]=n;
}
int removeq(QUEUE *pq){
return pq-&gt;data[++pq-&gt;front];
}
int isempty(QUEUE *pq){
return(pq-&gt;front==pq-&gt;rear);
}
void create(int a[10][10],int n){
printf("\n****TYPE 1 FOR YES & 0 FOR NO****\n");
for(int i=0;i&lt;n;i++){
for(int j=0;j&lt;n;j++){
a[i][j]=0;
if(i!=j){
printf("\nIs there any edge between %d & %d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
}
}
void bfs(int a[10][10],int n){
int v=0;
int visited[20]={0};
QUEUE q;
initq(&q);
printf("\nThe Breadth First Traversal is:\n");
visited[v]=1;
addq(&q,v);
while(!isempty(&q)){
v=removeq(&q);
printf("v%d\t",v+1);
for(int w=0;w&lt;n;w++){
if((a[v][w]==1)&&(visited[w]==0)){
addq(&q,w);
visited[w]=1;
}
}
}
}
int main(){
int a[10][10],n;
printf("\nEnter the no. of vertex: ");
scanf("%d",&n);
create(a,n);
bfs(a,n);
}

    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">8.Assign3_setBb</div>
<div class="code-area">
<button onclick="cc9()">Copy</button>
    <pre id="id9">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef struct node
{
int vertex;
struct node *next;
}NODE;
void create(int a[20][20],int n)
{
printf("\n***Enter 1 for Yes & 0 for No**\n");
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
a[i][j]=0;
if(i!=j){
printf("\nIs there edge between v%d & v%d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
}
}
void recdfs(int a[20][20],int n,int v)
{
static int visited[20]={0};
visited[v]=1;
printf("v%d\t",v+1);
for(int w=0;w&lt;n;w++)
{
if((a[v][w]==1)&&(visited[w]==0))
recdfs(a,n,w);
}
}
int main()
{
int a[20][20],n;
printf("\nEnter the no. of vertex: ");
scanf("%d",&n);
create(a,n);
printf("\nThe Depth First Search Traversal is: \n");
recdfs(a,n,0);
}

    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">9.Assign4_setA1</div>
<div class="code-area">
<button onclick="cc10()">Copy</button>
    <pre id="id10">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
int create(int a[10][10],int n)
{
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
a[i][j]=0;
if(i!=j)
{
printf("\nIs there edge between %d & %d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
}
}
void clist(int a[10][10],int n)
{
NODE *temp,*newnode;
for(int i=0;i&lt;n;i++)
{
list[i]=NULL;
for(int j=0;j&lt;n;j++)
{
if(a[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));
newnode-&gt;vertex=j+1;
newnode-&gt;next=NULL;
if(list[i]==NULL)
list[i]=temp=newnode;
else
temp-&gt;next=newnode;
temp=newnode;
}
}
}
}
void dlist(int n)
{
NODE *temp;
printf("\nThe Adjacency list is: ");
for(int i=0;i&lt;n;i++)
{
printf("v%d--&gt;",i+1);
temp=list[i];
while(temp)
{
printf("v%d--&gt;",temp-&gt;vertex);
temp=temp-&gt;next;
}
printf("NULL\n");
}
}
int main()
{
int a[10][10],n;
printf("\nEnter the no. of vertex: ");
scanf("%d",&n);
create(a,n);
clist(a,n);
dlist(n);
}

    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">10.Assign4_setA2</div>
<div class="code-area">
<button onclick="cc11()">Copy</button>
    <pre id="id11">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
int create(int a[10][10],int n)
{
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
a[i][j]=0;
if(i!=j)
{
printf("\nIs there edge between %d & %d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
}
}
void clist(int a[10][10],int n)
{
NODE *temp,*newnode;
for(int i=0;i&lt;n;i++)
{
list[i]=NULL;
for(int j=0;j&lt;n;j++)
{
if(a[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));
newnode-&gt;vertex=j+1;
newnode-&gt;next=NULL;
if(list[i]==NULL)
list[i]=temp=newnode;
else
temp-&gt;next=newnode;
temp=newnode;
}
}
}
}
void dlist(int n)
{
NODE *temp;
printf("\nThe Adjacency list is: ");
for(int i=0;i&lt;n;i++)
{
printf("v%d--&gt;",i+1);
temp=list[i];
while(temp)
{
printf("v%d--&gt;",temp-&gt;vertex);
temp=temp-&gt;next;
}
printf("NULL\n");
}
}
void inout(int a[10][10],int n)
{
int in=0,out=0,total=0;
printf("\nVertex\t\tIndegree\tOutdegree\tTotal Degree");
for(int i=0;i&lt;n;i++)
{
in=out=0;
for(int j=0;j&lt;n;j++)
{
in=in+a[j][i];
out=out+a[i][j];
}
total = in+out;
printf("\n%d\t\t%d\t\t%d\t\t%d",i+1,in,out,total);
}
}
int main()
{
int a[10][10],n;
printf("\nEnter the no. of vertex: ");
scanf("%d",&n);
create(a,n);
clist(a,n);
dlist(n);
inout(a,n);
}

    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">11.Assign4_setB1</div>
<div class="code-area">
<button onclick="cc12()">Copy</button>
    <pre id="id12">
#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#include&lt;stdlib.h&gt;
typedef struct node
{
int vertex;
struct node *next;
}NODE;
void create(int a[10][10],int n)
{
printf("\n****TYPE 1 FOR YES & 0 FOR NO****\n");
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
a[i][j]=0;
if(i!=j)
{
printf("\nIs there any edge between %d & %d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
}
}

void display(int a[10][10],int n)
{
printf("\nThe Matrix is: \n");
for(int i=0;i&lt;n;i++)
{
for(int j=0;j&lt;n;j++)
{
printf("%d\t",a[i][j]);
}
printf("\n");
}
}
void recdfs(int a[20][20],int n,int v)
{
static int visited[20]={0};
visited[v]=1;
printf("v%d\t",v+1);
for(int w=0;w&lt;n;w++)
{
if((a[v][w]==1)&&(visited[w]==0))
recdfs(a,n,w);
}
}

int main()
{
int a[10][10],n;
printf("\nEnter the no. of vertex: ");
scanf("%d",&n);
create(a,n);
display(a,n);
printf("\nThe Depth First Search Traversal is: \n");
recdfs(a,n,0);
}
    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">12.Assign5_setA1</div>
<div class="code-area">
<button onclick="cc13()">Copy</button>
    <pre id="id13">
#include&lt;stdio.h&gt;
int main()
{
int i,j,k,n,a[10][10],indeg[10],flag[10],count=0;
printf("Enter the no of vertices:\n");
scanf("%d",&n);
printf("Enter the adjacenecy matrix:\n");
for(i=0;i&lt;n;i++)
{
printf("Enter row %d\n",i+1);
for(j=0;j&lt;n;j++)
scanf("%d",&a[i][j]);
}
for(i=0;i&lt;n;i++)
{
indeg[i]=0;
flag[i]=0;
}
for(i=0;i&lt;n;i++)
for(j=0;j&lt;n;j++)
indeg[i]=indeg[i]+a[j][i];
printf("\n The topological order is:");
while(count&lt;n)
{
for(k=0;k&lt;n;k++)
{
if((indeg[k]==0)&&(flag[k]==0))
{
printf("%d",(k+1));
flag[k]=1;
}
for(i=0;i&lt;n;i++)
{
if(a[i][k]==1)indeg[k]--;
}
}
count++;
}
return 0;
}
    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">13.Assign5_setA2</div>
<div class="code-area">
<button onclick="cc14()">Copy</button>
    <pre id="id14">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define infinity 9999
#define MAX 20
int G[MAX][MAX],spanning[MAX][MAX],n;int prims();
int main()
{
int i,j,total_cost;
printf("Enter no. of vertices:");
scanf("%d",&n);
printf("\nEnter the adjacency matrix:\n");
for(i=0;i&lt;n;i++)
for(j=0;j&lt;n;j++)
scanf("%d",&G[i][j]);
total_cost=prims();
printf("\nspanning tree matrix:\n");
for(i=0;i&lt;n;i++)
{
printf("\n");
for(j=0;j&lt;n;j++)
printf("%d\t",spanning[i][j]);
}
printf("\n\nTotal cost of spanning tree=%d",total_cost);
return 0;
}
int prims()
{
int cost[MAX][MAX];
int u,v,min_distance,distance[MAX],from[MAX];
int visited[MAX],no_of_edges,i,min_cost,j;
for(i=0;i&lt;n;i++)
for(j=0;j&lt;n;j++)
{
if(G[i][j]==0)
cost[i][j]=infinity;
else
cost[i][j]=G[i][j];
spanning[i][j]=0;
}
distance[0]=0;
visited[0]=1;
for(i=1;i&lt;n;i++)
{
distance[i]=cost[0][i];
from[i]=0;
visited[i]=0;
}
min_cost=0;
no_of_edges=n-1;
while(no_of_edges&gt;0)
{
min_distance=infinity;
for(i=1;i&lt;n;i++)
if(visited[i]==0&&distance[i]&lt;min_distance)
{
v=i;
min_distance=distance[i];
}
u=from[v];
spanning[u][v]=distance[v];
spanning[v][u]=distance[v];
no_of_edges--;
visited[v]=1;for(i=1;i&lt;n;i++)
if(visited[1]==0&&cost[i][v]&lt;distance[i])
{
distance[i]=cost[i][v];
from[i]=v;
}
min_cost=min_cost+cost[u][v];
}
return(min_cost);
}
    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">14.Assign5_setB1</div>
<div class="code-area">
<button onclick="cc15()">Copy</button>
    <pre id="id15">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int i,j,k,a,b,u,v,n,ne=1;
int min,mincost=0,cost[9][9],parent[9];
int find(int);
int uni(int,int);
void main()
{
printf("\n\timplementation of kruskal's algorithm\n");
printf("\nenter the no. of vertices:");
scanf("%d",&n);
printf("\nenter the cost adjacency matrix:\n");
for(i=1;i&lt;=n;i++)
{
for(j=1;j&lt;=n;j++)
{
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
}
printf("the edges of minimum cost spanninf tree are\n");
while(ne&lt;n)
{
for(i=1,min=999;i&lt;=n;i++)
{
for(j=1;j&lt;=n;j++)
{
if(cost[i][j]&lt;min)
{
min=cost[i][j];
a=u=i;
b=v=j;
}
}
}
u=find(u);
v=find(v);
if(uni(u,v))
{
printf("%d edges (%d,%d)=%d\n",ne++,a,b,min);
mincost+=min;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n\tminimum cost+%d\n",mincost);
}
int find(int i)
{
while(parent[i])
i=parent[i];
return i;
}
int uni(int i,int j)
{
if(1!=j)
{
parent[j]=i;
return 1;
}
return 0;
}

    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">15.Assign6_setA</div>
<div class="code-area">
<button onclick="cc16()">Copy</button>
    <pre id="id16">
#include&lt;stdio.h&gt;
#define INFINITY 9999
#define MAX 10
void dijkstra(int G[MAX][MAX],int n,int startnode);
int main()
{
int G[MAX][MAX],i,j,n,u;
printf("enter no. of vertices:");
scanf("%d",&n);
printf("\nenter the adjacency matrix:\n");
for(i=0;i&lt;n;i++)
for(j=0;j&lt;n;j++)
scanf("%d",&G[i][j]);
printf("\nenter the starting node:");
scanf("%d",&u);
dijkstra(G,n,u);
return 0;
}
void dijkstra(int G[MAX][MAX],int n,int startnode)
{
int cost[MAX][MAX],distance[MAX],pred[MAX];
int visited[MAX],count,mindistance,nextnode,i,j;
for(i=0;i&lt;n;i++)
for(j=0;j&lt;n;j++)
if(G[i][j]==0)
cost[i][j]=INFINITY;else
cost[i][j]=G[i][j];
for(i=0;i&lt;n;i++)
{
distance[i]=cost[startnode][i];
pred[i]=startnode;
visited[i]=0;
}
distance[startnode]=0;
visited[startnode]=1;
count=1;
while(count&lt;n-1)
{
mindistance=INFINITY;
for(i=0;i&lt;n;i++)
if(distance[i]&lt;mindistance && !visited[i])
{
mindistance=distance[i];
nextnode=i;
}
visited[nextnode]=1;
for(i=0;i&lt;n;i++)
if(!visited[i])
if(mindistance+cost[nextnode][i]&lt;distance[i])
{
distance[i]=mindistance+cost[nextnode][i];
pred[i]=nextnode;
}
count++;
}
for(i=0;i&lt;n;i++)
if(i!=startnode)
{
printf("\n distance of node%d=%d",i,distance[i]);
printf("\n Path=%d",i);
j=i;
do
{
j=pred[j];
printf("&lt;-%d",j);
}while(j!=startnode);
}
}
    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">16.Assign6_setB</div>
<div class="code-area">
<button onclick="cc17()">Copy</button>
    <pre id="id17">
#include&lt;stdio.h&gt;
#define nV 4
#define INF 999
void printMatrix(int matrix[][nV]);
void floydWarshall(int graph[][nV])
{
int matrix[nV][nV],i,j,k;
for(i=0;i&lt;nV;i++)
for(j=0;j&lt;nV;j++)
matrix[i][j]=graph[i][j];
for(k=0;k&lt;nV;k++)
{for(i=0;i&lt;nV;i++)
{
for(j=0;j&lt;nV;j++)
{
if(matrix[i][k]+matrix[k][j]&lt;matrix[i][j])
matrix[i][j]=matrix[i][k]+matrix[k][j];
}
}
}
printMatrix(matrix);
}
void printMatrix(int matrix[][nV])
{
int i,j;
for(i=0;i&lt;nV;i++)
{
for(j=0;j&lt;nV;j++)
{
if(matrix[i][j]==INF)
printf("%4s",INF);
else
printf("%4d",matrix[i][j]);
}
printf("\n");
}
}
int main()
{
int graph[nV][nV]={{0,3,INF,5},{2,0,INF,4},{INF,1,0,INF},{INF,INF,2,0}};
floydWarshall(graph);
}

    </pre>
</div>
<div>
    <hr>
</div>

<div class="que-prompt">17.Assign7_setA</div>
<div class="code-area">
<button onclick="cc18()">Copy</button>
    <pre id="id18">
#include&lt;stdio.h&gt;
int hf(int key,int i)
{
return (key%10+i)%10;
}
void insert(int HT[10],int key)
{
int i,index;
for(i=0;i&lt;10;i++)
{
index=hf(key,i);
if(HT[index]==-1)
{
HT[index]=key;
return;
}
}printf("\nCould not insert key %d",key);
}
int search(int HT[10],int key)
{
int i,index;
for(i=0;i&lt;10;i++)
{
index=hf(key,i);
if(HT[index]==key)
return index;
}
return -1;
}
void delete(int HT[10],int key)
{
int index;
index=search(HT,key);
if(index==-1)
printf("\n %d key not found",key);
else
HT[index]=-1;
}
void showTable(int HT[10])
{
int i;
for(i=0;i&lt;10;i++)
printf("%d[%d]\n",i,HT[i]);
}
int main()
{
int HT[10],choice,key,index,i;
for(i=0;i&lt;10;i++)
HT[i]=-1;
do
{
printf("\n1:Insert\n2:Search\n3:Delete\n4:Exit\n\nEnter your choice: ");
scanf("%d",&choice);
switch(choice)
{
case 1:
printf("\nEnter the key to be inserted: ");
scanf("%d",&key);
insert(HT,key);
showTable(HT);
break;
case 2:
printf("\nEnter the key to be Searched: ");
scanf("%d",&key);
index=search(HT,key);
if(index==-1)
printf("\n %d not found",key);
else
printf("\n %d found at position %d",key,index);
break;
case 3:
printf("\nEnter the key to be Deleted: ");
scanf("%d",&key);
delete(HT,key);
showTable(HT);
break;
}
}while(choice!=4);
return 0;
}

    </pre>
</div>
<div>
    <hr>
</div>
<script src="script.js"></script>
</body>
</html>



